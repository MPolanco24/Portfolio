# -*- coding: utf-8 -*-
"""LSTM_Stock_prediction_Miguel_Polanco.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1vrY0lHsl2tjnzRP4CvGArBDX2HrCN_O6
"""

!pip install yfinance --upgrade --no-cache-dir

"""# Predict the stock prices using LSTM"""

#Import all the required libraries.
import math
import yfinance as yf
import numpy as np
import pandas as pd
from sklearn.preprocessing import MinMaxScaler
import matplotlib.pyplot as plt
import tensorflow as tf
from tensorflow import keras
from tensorflow.keras import layers

"""#Load the Apple stock price dataset from yahoo finance

Website: https://finance.yahoo.com/quote/AAPL/history?p=AAPL
"""

stock_data = yf.download('AAPL', start='2016-01-01', end='2024-03-25')
stock_data.head()

"""# Visualizing Stock Prices History

Use the Matplotlib plot method to create a line chart for historical close prices of AAPL.
"""

plt.figure(figsize=(15, 8))
plt.title('Apple Stock Prices History', fontsize = 16)
plt.plot(stock_data['Close'], linewidth = 4)
plt.xlabel('Date', fontsize = 16)
plt.ylabel('Prices ($)', fontsize = 16)

"""The AAPL shows an upward trend over the last five years.

#Data preprocessing

Prepare train and test datasets from the given dataset
"""

#Extract the closing prices from stock data and convert it into a number series
close_prices = stock_data['Close']
values = close_prices.values ###convert the dataframe into a numpy
print(values.shape)

# 80% of the dataset selected for training # math.ceil ensure that data size is rounded upto an integer
training_data_len = math.ceil(len(values)* 0.8)

# apply min max scaler to normalize the data between 0 and 1
scaler = MinMaxScaler(feature_range=(0,1))

#reshape the normalized data into a two-dimensional array for LSTM
scaled_data = scaler.fit_transform(values.reshape(-1,1))
print(scaled_data.shape)

# Use 80% dataset for training
train_data = scaled_data[0: training_data_len, :]

#Empty lists for a sequence of feature data (x_train) and a sequence of label data (y_train)
x_train = []
y_train = []

# Create a 60-days window of historical prices (i-60) as our feature data (x_train)
#following 60-days window as label data (y_train)
for i in range(60, len(train_data)):
    x_train.append(train_data[i-60:i, 0])
    y_train.append(train_data[i, 0])

#convert x_train and y_train into a numpy array for feeding into the neural network
x_train, y_train = np.array(x_train), np.array(y_train)

#print the shape of training data
print("Before reshaping the shape of train data:", x_train.shape)

"""# Reshape the data for LSTM to a three-dimensional array

"""

x_train = np.reshape(x_train, (x_train.shape[0], x_train.shape[1], 1))
print(x_train.shape[0])
print(x_train.shape[1])
print("After reshaping of train data:", x_train.shape) # [samples, timesteps, features]

"""#Prepare the test data"""

# extract the last 20% of the normalized/scaled dataset
test_data = scaled_data[training_data_len-60: , : ]

#create feature data (x_test) and label data (y_test) from the test set
x_test = []
y_test = values[training_data_len:]

for i in range(60, len(test_data)):
  x_test.append(test_data[i-60:i, 0])

#convert x_test to a numpy array
x_test = np.array(x_test)

#reshape x_test as [samples, timesteps, features]
x_test = np.reshape(x_test, (x_test.shape[0], x_test.shape[1], 1))

print(x_test.shape[0])
print(x_test.shape[1])
print("After reshaping of test data:", x_test.shape)

"""# Build the LSTM Model"""

#Sequential model --> linear stack of layers
model = keras.Sequential()

#LSTM layer with 100 neurons
##An LSTM layer requires a three-dimensional input and LSTMs by default will produce a two-dimensional output
#return sequence= True so that the output of the layer will be another sequence of the same length (3D input required for LSTM layers)
model.add(layers.LSTM(100, return_sequences=True, input_shape=(x_train.shape[1], 1)))

#LSTM layer, return sequence= False, return the last output in the output sequence.
model.add(layers.LSTM(100, return_sequences=False))

#Dense layer 25 neurons
model.add(layers.Dense(25))

#output layer with 1 neuron
model.add(layers.Dense(1,activation='linear'))

#summary of network architecture
model.summary()

"""#Compile and run the LSTM model"""

model.compile(optimizer = 'adam', loss = 'mean_squared_error') #use default learning rate = 0.001
model.fit(x_train, y_train, batch_size= 32, epochs=50) ###train the model

import h5py
model.save("LSTM.h5")

"""#Model evaluation"""

predictions = model.predict(x_test)

#inverse the min max transform to see actual values of data
predictions = scaler.inverse_transform(predictions)

#Root mean squared error to calculate the discrepancy between actual prices and predicted prices
rmse = np.sqrt(np.mean(predictions - y_test)**2)
print (rmse)

"""#Visualizing the stock prices for historical data again for comparison with the predictions



"""

plt.figure(figsize=(15, 8))
plt.title('Apple Stock Prices History', fontsize = 16)
plt.plot(stock_data['Close'], linewidth = 4)
plt.xlabel('Date', fontsize = 16)
plt.ylabel('Prices ($)', fontsize = 16)

"""#Visualizing the Predicted Prices"""

#Use the filter method to only retain the closing price column in the dataframe
data = stock_data.filter(['Close'])

#Split the stock data into three plotting regions: training, validation and prediction
train = data[:training_data_len]
validation = data[training_data_len:]
validation['Predictions'] = predictions
plt.figure(figsize=(16,8))
plt.title('Prediction of apple stock prices ', fontsize = 18)
plt.xlabel('Date', fontsize = 18)
plt.ylabel('Close Price USD ($)', fontsize = 18)
plt.plot(train, linewidth = 4)
plt.plot(validation[['Close', 'Predictions']], linewidth = 4)
plt.legend(['Train', 'Val', 'Predictions'], loc='lower right', fontsize = 16)
plt.show()

"""From the above graph we can see the predicted stock prices follow the trend of the real stock prices closely.

This shows the effectiveness of the LSTM for sequential or time series data such as stock price.
"""